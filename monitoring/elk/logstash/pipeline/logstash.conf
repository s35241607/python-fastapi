# Logstash Configuration for Enterprise Ticket Management System
# Processes logs from FastAPI, NGINX, PostgreSQL, and system logs

input {
  # FastAPI Application Logs
  beats {
    port => 5044
    type => "fastapi"
  }
  
  # NGINX Access Logs
  file {
    path => "/var/log/nginx/access.log"
    type => "nginx_access"
    start_position => "beginning"
  }
  
  # NGINX Error Logs
  file {
    path => "/var/log/nginx/error.log"
    type => "nginx_error"
    start_position => "beginning"
  }
  
  # PostgreSQL Logs
  file {
    path => "/var/log/postgresql/postgresql-*.log"
    type => "postgresql"
    start_position => "beginning"
  }
  
  # System Logs
  file {
    path => "/var/log/syslog"
    type => "syslog"
    start_position => "beginning"
  }
  
  # Docker Container Logs
  file {
    path => "/var/lib/docker/containers/*/*-json.log"
    type => "docker"
    codec => "json"
    start_position => "beginning"
  }
}

filter {
  # FastAPI Log Processing
  if [type] == "fastapi" {
    json {
      source => "message"
    }
    
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    if [level] {
      mutate {
        uppercase => [ "level" ]
      }
    }
    
    # Extract request information
    if [request_id] {
      mutate {
        add_field => { "[@metadata][request_id]" => "%{request_id}" }
      }
    }
    
    # Parse user information
    if [user_id] {
      mutate {
        add_field => { "[@metadata][user_id]" => "%{user_id}" }
      }
    }
  }
  
  # NGINX Access Log Processing
  if [type] == "nginx_access" {
    grok {
      match => { 
        "message" => "%{NGINXACCESS}"
      }
    }
    
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }
    
    mutate {
      convert => { 
        "response" => "integer"
        "bytes" => "integer"
        "response_time" => "float"
      }
    }
    
    # Classify request types
    if [request] =~ /^POST \/tickets\// {
      mutate { add_tag => [ "ticket_creation" ] }
    } else if [request] =~ /^GET \/tickets\// {
      mutate { add_tag => [ "ticket_access" ] }
    } else if [request] =~ /^POST \/auth\/login/ {
      mutate { add_tag => [ "authentication" ] }
    } else if [request] =~ /^POST \/approvals\// {
      mutate { add_tag => [ "approval_action" ] }
    }
  }
  
  # NGINX Error Log Processing
  if [type] == "nginx_error" {
    grok {
      match => { 
        "message" => "(?<timestamp>%{YEAR}[./-]%{MONTHNUM}[./-]%{MONTHDAY}[- ]%{TIME}) \[%{LOGLEVEL:severity}\] %{POSINT:pid}#%{NUMBER:tid}: (\*%{NUMBER:connection_id} )?%{GREEDYDATA:nginx_message}"
      }
    }
    
    date {
      match => [ "timestamp", "yyyy/MM/dd HH:mm:ss" ]
    }
  }
  
  # PostgreSQL Log Processing
  if [type] == "postgresql" {
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{POSINT:pid}\] %{WORD:level}:  %{GREEDYDATA:pg_message}"
      }
    }
    
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS zzz" ]
    }
    
    # Extract slow query information
    if [pg_message] =~ /duration: (\d+\.\d+) ms/ {
      grok {
        match => { "pg_message" => "duration: (?<query_duration>\d+\.\d+) ms" }
      }
      mutate {
        convert => { "query_duration" => "float" }
      }
      
      if [query_duration] and [query_duration] > 1000 {
        mutate { add_tag => [ "slow_query" ] }
      }
    }
  }
  
  # Docker Container Log Processing
  if [type] == "docker" {
    # Extract container information from log path
    grok {
      match => { 
        "path" => "/var/lib/docker/containers/(?<container_id>[^/]+)/.*"
      }
    }
    
    # Parse JSON log format
    if [log] {
      mutate {
        rename => { "log" => "message" }
      }
    }
    
    date {
      match => [ "time", "ISO8601" ]
    }
  }
  
  # Common processing for all log types
  
  # Add environment information
  mutate {
    add_field => { 
      "environment" => "production"
      "application" => "enterprise-ticket-system"
    }
  }
  
  # Anonymize sensitive data
  if [message] =~ /password/ {
    mutate {
      gsub => [ "message", "password=[^&\s]*", "password=***" ]
    }
  }
  
  if [message] =~ /token/ {
    mutate {
      gsub => [ "message", "token=[^&\s]*", "token=***" ]
    }
  }
  
  # Geolocation for IP addresses
  if [clientip] {
    geoip {
      source => "clientip"
      target => "geoip"
    }
  }
  
  # Add severity level based on HTTP status codes
  if [response] {
    if [response] >= 500 {
      mutate { add_field => { "severity" => "error" } }
    } else if [response] >= 400 {
      mutate { add_field => { "severity" => "warning" } }
    } else if [response] >= 200 {
      mutate { add_field => { "severity" => "info" } }
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "enterprise-tickets-%{+YYYY.MM.dd}"
    template_name => "enterprise-tickets"
    template_pattern => "enterprise-tickets-*"
    template => "/usr/share/logstash/templates/enterprise-tickets.json"
  }
  
  # Output critical errors to separate index
  if [severity] == "error" or "slow_query" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "enterprise-tickets-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Output security-related events
  if "authentication" in [tags] or [response] == 401 or [response] == 403 {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "enterprise-tickets-security-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}